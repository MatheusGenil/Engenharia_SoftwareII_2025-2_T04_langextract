# -*- coding: utf-8 -*-
"""CodigoRivaldoPorCommits.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1u5JnNCWnoLA10gsTFWVhpnpya4voTcdh
"""

from transformers import pipeline
import requests
import re

class HuggingFaceWrapper:
    def __init__(self, model_name: str):
        self.pipeline = pipeline("zero-shot-classification", model=model_name)

    def classify_text(self, text: str, candidate_labels: list[str]):
        return self.pipeline(text, candidate_labels=candidate_labels)

# ======================================================
# ğŸ” COLE O REPOSITÃ“RIO AQUI (owner/repo)
repo = "google/langextract"  # Exemplo
# ======================================================

# ğŸ” Pega commits recentes via API pÃºblica do GitHub
url = f"https://api.github.com/repos/{repo}/commits"
response = requests.get(url)

if response.status_code != 200:
    raise Exception(f"Erro ao buscar commits: {response.status_code}")

commits_data = response.json()

# Extrai mensagens dos commits
commit_messages = [
    c["commit"]["message"] for c in commits_data if "commit" in c
]

# ğŸ”§ Concatena todas as mensagens
commit_text = "\n".join(commit_messages)

print(f"âœ… {len(commit_messages)} mensagens de commit coletadas do repositÃ³rio '{repo}'.")

# ğŸ” Termos de busca relevantes (para filtrar mensagens Ãºteis)
termos_busca = [
    "architecture", "architectural", "pattern", "design",
    "provider", "plugin", "module", "interface", "layer", "service",
    "refactor", "dependency", "mvc", "microservice"
]

# ğŸ§¹ Filtra commits que contÃªm termos relevantes
padrao = re.compile("|".join(termos_busca), flags=re.IGNORECASE)
commits_relevantes = [msg for msg in commit_messages if padrao.search(msg)]
texto_filtrado = "\n".join(commits_relevantes)

if not texto_filtrado.strip():
    print("âš ï¸ Nenhum commit relevante encontrado, usando todos os commits.")
    texto_filtrado = commit_text
else:
    print(f"âœ… {len(commits_relevantes)} commits relevantes encontrados.\n")

# ğŸ§  Labels de arquitetura
candidate_labels = [
    "Monolithic",
    "Microservices",
    "Serverless",
    "Event Driven",
    "Layered",
    "Hexagonal",
    "Clean Architecture",
    "Service Oriented Architecture",
    "Client Server",
    "MVC",
    "Singleton",
    "Factory Method",
    "Observer",
    "Strategy",
    "Adapter",
    "Facade",
    "Decorator",
    "Repository",
    "Command",
    "Dependency Injection",
    "Modular",
    "Pipe and Filter",
    "Provider-based Architecture",
    "Plugin-based Architecture"
]

# âœ… Modelo compatÃ­vel
model_name = "facebook/bart-large-mnli"
hf = HuggingFaceWrapper(model_name)

# ğŸ” ClassificaÃ§Ã£o baseada nas mensagens de commit
result = hf.classify_text(texto_filtrado, candidate_labels)

print("\n============== " + model_name + " ==============")
print("\nğŸ—ï¸  Resultado da inferÃªncia de arquitetura:")
for label, score in zip(result["labels"], result["scores"]):
    print(f"{label}: {score:.2%}")

print(f"\nâ¡ï¸  Arquitetura mais provÃ¡vel: {result['labels'][0]} (confianÃ§a: {result['scores'][0]:.2%})")
